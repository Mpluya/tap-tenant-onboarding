#@ load("@ytt:data", "data")
#@ load("@ytt:yaml", "yaml")
#@ load("@ytt:base64", "base64")
---
apiVersion: kappctrl.k14s.io/v1alpha1
kind: App
metadata:
  annotations:
    kapp.k14s.io/disable-wait: ""
  name: app-onboarding
  namespace: tap-install
spec:
  serviceAccountName: tap-tap-install-sa
  fetch:
  - inline:
      pathsFrom:
      - secretRef:
          name: app-onboarding-files
  template:
  - ytt:
      ignoreUnknownComments: true
      valuesFrom:
      - secretRef:
          name: app-onboarding-secrets
      - secretRef:
          name: app-onboarding-values
  - kbld: {}
  deploy:
  - kapp: 
      rawOptions: 
      - --diff-changes=true
      - --dangerous-override-ownership-of-existing-resources=true
---
apiVersion: v1
kind: Secret
metadata:
  name: app-onboarding-values
stringData:
  values.yaml: #@ yaml.encode({ "additional_users": data.values.additional_users })
---
apiVersion: v1
kind: Secret
metadata:
  name: app-onboarding-files
stringData:
  additional-users.yaml: |
    #@ load("@ytt:overlay", "overlay")
    #@ load("@ytt:data", "data")
    #@ load("@ytt:base64", "base64")
    #@ load("@ytt:json", "json")
    #@ load("@ytt:yaml", "yaml")

    #@ for user in data.values.additional_users:
    ---
    apiVersion: v1
    kind: Namespace
    metadata:
      name: #@ user.namespace
      labels:
        policy.sigstore.dev/include: "true"
    ---
    apiVersion: v1
    kind: Secret
    metadata:
      name: tap-registry
      namespace: #@ user.namespace
      annotations:
        secretgen.carvel.dev/image-pull-secret: ""
    type: kubernetes.io/dockerconfigjson
    data:
      .dockerconfigjson: e30K
    ---
    apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: default #! use value from "Install Default Supply Chain"
      namespace: #@ user.namespace
    secrets:
      - name: registry-credentials
      - name: cosign
      - name: gitops-ssh
    imagePullSecrets:
      - name: tap-registry
      - name: registry-credentials
    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: Role
    metadata:
      name: tekton-role
      namespace: #@ user.namespace
    rules:
    - apiGroups: [tekton.dev]
      resources: [tasks, taskruns, pipelineruns]
      verbs: ['*']
    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: tekton-rolebinding
      namespace: #@ user.namespace
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: tekton-role
    subjects:
      - kind: ServiceAccount
        name: default
    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: default-permit-deliverable
      namespace: #@ user.namespace
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: deliverable
    subjects:
      - kind: ServiceAccount
        name: default #! use value from "Install Default Supply Chain"
        namespace: #@ user.namespace
    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: default-permit-workload
      namespace: #@ user.namespace
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: workload
    subjects:
      - kind: ServiceAccount
        name: default #! use value from "Install Default Supply Chain"
        namespace: #@ user.namespace
    ---
    #@ if "viewer" in user:
    apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: app-viewer
      namespace: #@ user.namespace
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: app-viewer
    subjects:
    - apiGroup: rbac.authorization.k8s.io
      kind: Group
      name: #@ user.viewer
    #@ end
    ---
    #@ if "editor" in user:
    apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: app-editor
      namespace: #@ user.namespace
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: app-editor
    subjects:
    - apiGroup: rbac.authorization.k8s.io
      kind: Group
      name: #@ user.editor
    #@ end
    ---
    #@ if "operator" in user:
    apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: app-operator
      namespace: #@ user.namespace
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: app-operator
    subjects:
    - apiGroup: rbac.authorization.k8s.io
      kind: Group
      name: #@ user.operator
    #@ end
    ---

    apiVersion: scanning.apps.tanzu.vmware.com/v1beta1
    kind: ScanPolicy
    metadata:
      name: scan-policy
      namespace: #@ "{}".format(user.namespace)
      labels:
        'app.kubernetes.io/part-of': 'enable-in-gui'
    spec:
      regoFile: |
        package main

        # Accepted Values: "Critical", "High", "Medium", "Low", "Negligible", "UnknownSeverity"
        notAllowedSeverities := ["UnknownSeverity"]
        ignoreCves := []

        contains(array, elem) = true {
          array[_] = elem
        } else = false { true }

        isSafe(match) {
          severities := { e | e := match.ratings.rating.severity } | { e | e := match.ratings.rating[_].severity }
          some i
          fails := contains(notAllowedSeverities, severities[i])
          not fails
        }

        isSafe(match) {
          ignore := contains(ignoreCves, match.id)
          ignore
        }

        deny[msg] {
          comps := { e | e := input.bom.components.component } | { e | e := input.bom.components.component[_] }
          some i
          comp := comps[i]
          vulns := { e | e := comp.vulnerabilities.vulnerability } | { e | e := comp.vulnerabilities.vulnerability[_] }
          some j
          vuln := vulns[j]
          ratings := { e | e := vuln.ratings.rating.severity } | { e | e := vuln.ratings.rating[_].severity }
          not isSafe(vuln)
          msg = sprintf("CVE %s %s %s", [comp.name, vuln.id, ratings])
        }
    ---
    apiVersion: packaging.carvel.dev/v1alpha1
    kind: PackageInstall
    metadata:
      name: #@ "grype-{}".format(user.namespace)
      namespace: tap-install
    spec:
      packageRef:
        refName: grype.scanning.apps.tanzu.vmware.com
        versionSelection:
          constraints: 1.3.0
      serviceAccountName: tap-tap-install-sa
      values:
      - secretRef:
          name: #@ "grype-values-{}".format(user.namespace)
    ---
    apiVersion: v1
    kind: Secret
    metadata:
      name: #@ "grype-values-{}".format(user.namespace)
      namespace: tap-install
    stringData:
      values.yaml: #@ yaml.encode({ "namespace": user.namespace, "targetImagePullSecret": "registry-credentials" })
    ---
    apiVersion: v1
    kind: Secret
    metadata:
      name: cosign
      namespace: #@ user.namespace
      annotations:
        kpack.io/cosign.docker-media-types: "1"
    type: Opaque
    data:
      cosign.key: #@ data.values.cosign_private
      cosign.password: #@ data.values.cosign_password
      cosign.pub: #@ data.values.cosign_public
    ---
    apiVersion: v1
    kind: Secret
    metadata:
      name: jenkins-secret
      namespace: #@ user.namespace
    type: Opaque
    stringData:
      url: #@ data.values.jenkins_url
      username: #@ data.values.jenkins_username
      password: #@ data.values.jenkins_password
    ---
    apiVersion: v1
    kind: PersistentVolumeClaim
    metadata:
      name: supplychainpvc
      namespace: #@ "{}".format(user.namespace)
    spec:
      accessModes:
      - ReadWriteMany
      storageClassName: azurefile
      resources:
        requests:
          storage: 2Gi
    ---
    apiVersion: tekton.dev/v1beta1
    kind: Pipeline
    metadata:
      name: developer-defined-tekton-pipeline-angular
      namespace: #@ "{}".format(user.namespace)
      labels:
        apps.tanzu.vmware.com/pipeline: test
        apps.tanzu.vmware.com/language: angular
    spec:
      params:
        - name: source-url
        - name: source-revision
      tasks:
        - name: test
          params:
            - name: source-url
              value: $(params.source-url)
            - name: source-revision
              value: $(params.source-revision)
          taskSpec:
            params:
              - name: source-url
              - name: source-revision
            steps:
              - name: test
                image: index.docker.io/tapsme/angular-chrome-headless@sha256:f5c2b3112f35aa0bdbd945ddf0674e528748dd7cd75a18846a81e2cd04c9fba1
                script: |-
                  cd `mktemp -d`
                  wget -qO- $(params.source-url) | tar xvz -m
                  npm i
                  npm run test
    ---
    apiVersion: tekton.dev/v1beta1
    kind: Pipeline
    metadata:
      name: developer-defined-tekton-pipeline-dotnet
      namespace: #@ "{}".format(user.namespace)
      labels:
        apps.tanzu.vmware.com/pipeline: test
        apps.tanzu.vmware.com/language: dotnet
    spec:
      params:
        - name: source-url
        - name: source-revision
      tasks:
        - name: test
          params:
            - name: source-url
              value: $(params.source-url)
            - name: source-revision
              value: $(params.source-revision)
          taskSpec:
            params:
              - name: source-url
              - name: source-revision
            steps:
              - name: test
                image: index.docker.io/tapsme/dotnet-with-headless-chrome@sha256:00a8a73b17446f94bde8718b10f3a9d2e3b6e44b4cce46b848abd84ed6efee27
                script: |-
                  cd `mktemp -d`
                  wget -qO- $(params.source-url) | tar xvz -m                 
                  dotnet test *.sln

    #@ if "exclude_resources" not in user or ("exclude_resources" in user and "developer-defined-tekton-pipeline" not in user.exclude_resources):
    ---
    apiVersion: v1
    kind: Secret  
    type: service.binding/maven
    metadata:
      namespace: #@ "{}".format(user.namespace)
      name: maven-settings
    stringData:
      type: maven
      provider: sample
      settings.xml: #@ data.values.settings_xml
    ---
    apiVersion: tekton.dev/v1beta1
    kind: Pipeline
    metadata:
      name: developer-defined-tekton-pipeline
      namespace: #@ "{}".format(user.namespace)
      labels:
        apps.tanzu.vmware.com/pipeline: test
        apps.tanzu.vmware.com/language: java
    spec:
      params:
      - name: source-url
      - name: source-revision
      workspaces:
      - name: custom-maven-settings
      - name: maven-settings
      - name: supplychain-workspace
      tasks:
      - name: test
        params:
        - name: source-url
          value: $(params.source-url)
        - name: source-revision
          value: $(params.source-revision)
        workspaces:
        - name: custom-maven-settings
          workspace: custom-maven-settings
        - name: supplychain-workspace
          workspace: supplychain-workspace
        - name: maven-settings
          workspace: maven-settings
        taskSpec:
          params:
          - name: source-url
          - name: source-revision
          workspaces:
          - name: custom-maven-settings
          - name: supplychain-workspace
          - name: maven-settings
          steps:
            - name: test
              image: tapsme/gradle:latest
              script: |-
                set -ex
                cd `mktemp -d`
                wget -qO- $(params.source-url) | tar xvz -m
                ./mvnw test -Dmaven.repo.local=$(workspaces.maven-settings.path) -s $(workspaces.custom-maven-settings.path)/settings.xml
    #@ end
    #@ registry_url = data.values.container_registry_location
    #@ registry_username = data.values.container_registry_username
    #@ registry_password = data.values.container_registry_password
    #@ docker_auth = base64.encode("{}:{}".format(registry_username, registry_password))
    #@ docker_creds = {"username": registry_username, "password": registry_password, "auth": docker_auth}
    ---
    apiVersion: tekton.dev/v1beta1
    kind: Task
    metadata:
      name: sonarqube-scanner-dotnet
      namespace: #@ "{}".format(user.namespace)
      labels:
        apps.tanzu.vmware.com/language: "dotnet"
        apps.tanzu.vmware.com/sonarqube: "sonarqube"
      annotations:
        tekton.dev/pipelines.minVersion: "0.12.1"
        tekton.dev/categories: Security
        tekton.dev/tags: security
        tekton.dev/displayName: "sonarqube scanner"
        tekton.dev/platforms: "linux/amd64"
    spec:
      params:
        - name: SONAR_HOST_URL
          description: Host URL where the sonarqube server is running
          default: ""
        - name: SONAR_PROJECT_KEY
          description: Project's unique key
          default: ""
        - name: SONAR_LOGIN
          description: Auth for the project
          default: ""
        - name: source-url
          description: Location of the source code
        - name: source-revision
          description: i.e. git hash
          default: ""
        - name: WAIT_ON_SONAR_ANALYSIS
          description: toggle to wait until sonarqube analysis is complete

      workspaces:
        - name: maven-settings
        - name: supplychain-workspace

      
      steps:
        - name: pull-code
          image: index.docker.io/tapsme/gradle@sha256:ba5d54bc93e3d7ae95481963c4cbd171100804a4fc64baf2ebabf0329c9e1179
          workingDir: $(workspaces.supplychain-workspace.path)
          script: |
            #!/usr/bin/env bash
            set -ex
            wget -qO- $(params.source-url) | tar xvz

        - name: sonar-scan
          image: index.docker.io/tapsme/dotnetsonar@sha256:0122ff42df5e2121ad3100dfca309e2f9cdf06d545d6e031f3e70f332b871a18
          workingDir: $(workspaces.supplychain-workspace.path)
          script: |
            #!/usr/bin/env bash
            set -ex
            dotnet-sonarscanner begin /k:$(params.SONAR_PROJECT_KEY) /d:sonar.host.url=$(params.SONAR_HOST_URL) /d:sonar.login=$(params.SONAR_LOGIN)
            dotnet build *.sln
            dotnet-sonarscanner end /d:sonar.login=$(params.SONAR_LOGIN)
    ---
    apiVersion: tekton.dev/v1beta1
    kind: Task
    metadata:
      name: sonarqube-scanner
      namespace: #@ "{}".format(user.namespace)
      labels:
        apps.tanzu.vmware.com/language: "java"
        apps.tanzu.vmware.com/sonarqube: "sonarqube"
      annotations:
        tekton.dev/pipelines.minVersion: "0.12.1"
        tekton.dev/categories: Security
        tekton.dev/tags: security
        tekton.dev/displayName: "sonarqube scanner"
        tekton.dev/platforms: "linux/amd64"
    spec:
      params:
        - name: SONAR_HOST_URL
          description: Host URL where the sonarqube server is running
          default: ""
        - name: SONAR_PROJECT_KEY
          description: Project's unique key
          default: ""
        - name: SONAR_LOGIN
          description: Auth for the project
          default: ""
        - name: source-url
          description: Location of the source code
        - name: source-revision
          description: i.e. git hash
          default: ""
        - name: WAIT_ON_SONAR_ANALYSIS
          description: toggle to wait until sonarqube analysis is complete

      workspaces:
        - name: custom-maven-settings
        - name: maven-settings
        - name: supplychain-workspace

      steps:
        - name: compile
          image: index.docker.io/tapsme/gradle@sha256:ba5d54bc93e3d7ae95481963c4cbd171100804a4fc64baf2ebabf0329c9e1179
          workingDir: $(workspaces.supplychain-workspace.path)
          script: |
            #!/usr/bin/env bash
            set -ex
            wget -qO- $(params.source-url) | tar xvz
            ./mvnw compile -Dmaven.repo.local=$(workspaces.maven-settings.path) -s $(workspaces.custom-maven-settings.path)/settings.xml
        - name: sonar-properties-create
          image: index.docker.io/tapsme/gradle@sha256:ba5d54bc93e3d7ae95481963c4cbd171100804a4fc64baf2ebabf0329c9e1179
          workingDir: $(workspaces.supplychain-workspace.path)
          script: |
            #!/usr/bin/env bash
            replaceValues() {
              filename=$1
              thekey=$2
              newvalue=$3
              if ! grep -R "^[#]*\s*${thekey}=.*" $filename >/dev/null; then
                echo "APPENDING because '${thekey}' not found"
                echo "" >>$filename
                echo "$thekey=$newvalue" >>$filename
              else
                echo "SETTING because '${thekey}' found already"
                sed -ir "s|^[#]*\s*${thekey}=.*|$thekey=$newvalue|" $filename
              fi
            }

            # If we were given a properties file, then use that.
            if [[ -f $(workspaces.supplychain-workspace.path)/sonar-project.properties ]]; then
              echo "using user provided sonar-project.properties file"
              cp -RL $(workspaces.supplychain-workspace.path)/sonar-project.properties $(workspaces.supplychain-workspace.path)/sonar-project.properties
            fi
            if [[ -f $(workspaces.supplychain-workspace.path)/sonar-project.properties ]]; then

              # Allow overrides from parameters passed in from the supply chain.
              if [[ -n "$(params.SONAR_HOST_URL)" ]]; then
                replaceValues $(workspaces.supplychain-workspace.path)/sonar-project.properties sonar.host.url $(params.SONAR_HOST_URL)
              fi
              if [[ -n "$(params.SONAR_PROJECT_KEY)" ]]; then
                replaceValues $(workspaces.supplychain-workspace.path)/sonar-project.properties sonar.projectKey $(params.SONAR_PROJECT_KEY)
              fi
              if [[ -n "$(params.SONAR_LOGIN)" ]]; then
                replaceValues $(workspaces.supplychain-workspace.path)/sonar-project.properties sonar.login $(params.SONAR_LOGIN)
              fi
            else
              touch sonar-project.properties
              echo "sonar.projectKey=$(params.SONAR_PROJECT_KEY)" >> sonar-project.properties
              echo "sonar.host.url=$(params.SONAR_HOST_URL)" >> sonar-project.properties
              echo "sonar.login=$(params.SONAR_LOGIN)" >> sonar-project.properties
              echo "sonar.sources=." >> sonar-project.properties
            fi
            echo "---------------------------"
            cat $(workspaces.supplychain-workspace.path)/sonar-project.properties

        - name: sonar-scan
          image: index.docker.io/tapsme/sonar-scanner-cli@sha256:b8c95a37025f3c13162118cd55761ea0b2a13d1837f9deec51b7b6d82c52040a
          workingDir: $(workspaces.supplychain-workspace.path)
          command:
            - sonar-scanner
        
        - name: quality-gate
          image: index.docker.io/tapsme/alpine-bash-curl-jq@sha256:a5369f1e4e9d139ed6a4064686cd0ff57a75f8d1e928944c540fe753c332acfd
          workingDir: $(workspaces.supplychain-workspace.path)
          script: |
            #!/usr/bin/env bash
            if [ -z "$(params.WAIT_ON_SONAR_ANALYSIS)" ] || [ "$(params.WAIT_ON_SONAR_ANALYSIS)" == "false" ]; then
              echo "not waiting for analysis to finish"
              exit 0
            fi

            metadataFile=$(workspaces.supplychain-workspace.path)/.scannerwork/report-task.txt
            sonarPropsFile=$(workspaces.supplychain-workspace.path)/sonar-project.properties
            if [[ ! -f "$metadataFile" ]]; then
              echo "$metadataFile does not exist."
              exit 1
            fi

            cat $metadataFile
            serverUrl="$(sed -n 's/serverUrl=\(.*\)/\1/p' "${metadataFile}")"
            ceTaskUrl="$(sed -n 's/ceTaskUrl=\(.*\)/\1/p' "${metadataFile}")"
            sonarToken="$(sed -n 's/sonar.login=\(.*\)/\1/p' "${sonarPropsFile}")"

            if [ -z "${serverUrl}" ] || [ -z "${ceTaskUrl}" ]; then
              echo "Invalid report metadata file."
              exit 1
            fi

            task="$(curl --silent --fail --show-error --user "${sonarToken}": "${ceTaskUrl}")"
            status="$(jq -r '.task.status' <<< "$task")"

            until [[ ${status} != "PENDING" && ${status} != "IN_PROGRESS" ]]; do
              printf '.'
              sleep 5s
              task="$(curl --silent --fail --show-error --user "${sonarToken}": "${ceTaskUrl}")"
              status="$(jq -r '.task.status' <<< "$task")"
            done

            analysisId="$(jq -r '.task.analysisId' <<< "${task}")"
            echo "analysisId: " $analysisId
            
            qualityGateUrl="${serverUrl}/api/qualitygates/project_status?analysisId=${analysisId}"
            
            qualityGateStatus="$(curl --silent --fail --show-error --user "${sonarToken}": "${qualityGateUrl}" | jq -r '.projectStatus.status')"

            if [[ ${qualityGateStatus} == "OK" ]]; then
              echo "quality-gate-status::PASSED"
            elif [[ ${qualityGateStatus} == "WARN" ]]; then
              echo "quality-gate-status::WARN"
            elif [[ ${qualityGateStatus} == "ERROR" ]]; then
              echo "quality-gate-status::FAILED"
              exit 1
            else
              echo "quality-gate-status::FAILED"
              exit 1
            fi
    ---
    apiVersion: v1
    data:
      .dockerconfigjson: #@ base64.encode(json.encode({"auths": {registry_url: docker_creds}}))
    kind: Secret
    metadata:
      name: registry-credentials
      namespace: #@ "{}".format(user.namespace)
    type: kubernetes.io/dockerconfigjson
    ---
    apiVersion: v1
    kind: Secret
    metadata:
      name: gitops-ssh
      namespace: #@ "{}".format(user.namespace)
      annotations:
        tekton.dev/git-0: #@ data.values.git_url
    type: kubernetes.io/ssh-auth
    data:
      identity: #@ data.values.git_ssh_private
      identity.pub: #@ data.values.git_ssh_public
      known_hosts: #@ data.values.git_ssh_known_hosts
      ssh-privatekey: #@ data.values.git_ssh_private
    ---
    #@ if "custom" in user:
    apiVersion: kappctrl.k14s.io/v1alpha1
    kind: App
    metadata:
      name: #@ "{}-addons".format(user.namespace)
      namespace: tap-install
    spec:
      serviceAccountName: tap-tap-install-sa
      fetch:
      - git:
          url: ssh://git@github.com/Mpluya/tap-tenant-onboarding
          ref: origin/1.3
          subPath: #@ "tenants/{}".format(user.namespace)
          secretRef: 
            name: tap-install-gitops-ssh-external-secret
      template:
      - ytt:
          inline:
            paths:
              ns-overlay.yaml: #@ "#@ load(\"@ytt:data\", \"data\")\n#@ load(\"@ytt:overlay\", \"overlay\")\n#@overlay/match by=overlay.all, expects=\"1+\"\n---\nmetadata:\n  #@overlay/match missing_ok=True\n  namespace: {}".format(user.namespace)
      deploy:
      - kapp:
          rawOptions:
          - --diff-changes=true
    #@ end  
    #@ end