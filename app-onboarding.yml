#@ load("@ytt:data", "data")
#@ load("@ytt:yaml", "yaml")
---
apiVersion: kappctrl.k14s.io/v1alpha1
kind: App
metadata:
  name: app-onboarding
spec:
  serviceAccountName: tap-tap-install-sa
  fetch:
  - inline:
      pathsFrom:
      - secretRef:
          name: app-onboarding-files
  template:
  - ytt:
      ignoreUnknownComments: true
      valuesFrom:
      - secretRef:
          name: app-onboarding-secrets
      - secretRef:
          name: app-onboarding-values
  - kbld: {}
  deploy:
  - kapp: 
      rawOptions: ["--dangerous-override-ownership-of-existing-resources=true"]
---
apiVersion: v1
kind: Secret
metadata:
  name: app-onboarding-values
stringData:
  values.yaml: #@ yaml.encode({ "additional_users": data.values.additional_users })
---
apiVersion: v1
kind: Secret
metadata:
  name: app-onboarding-files
stringData:
  additional-users.yaml: |
    #@ load("@ytt:overlay", "overlay")
    #@ load("@ytt:data", "data")
    #@ load("@ytt:base64", "base64")
    #@ load("@ytt:json", "json")
    #@ load("@ytt:yaml", "yaml")

    #@ for user in data.values.additional_users:
    ---
    apiVersion: v1
    kind: Namespace
    metadata:
      name: #@ user
    ---
    apiVersion: v1
    kind: Secret
    metadata:
      name: tap-registry
      namespace: #@ user
      annotations:
        secretgen.carvel.dev/image-pull-secret: ""
    type: kubernetes.io/dockerconfigjson
    data:
      .dockerconfigjson: e30K

    ---
    apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: default #! use value from "Install Default Supply Chain"
      namespace: #@ user
    secrets:
      - name: registry-credentials
    imagePullSecrets:
      - name: tap-registry
      - name: registry-credentials

    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: Role
    metadata:
      name: kapp-permissions
      namespace: #@ user
      annotations:
        kapp.k14s.io/change-group: "role"
    rules:
    - apiGroups:
        - packaging.carvel.dev
      resources: ['packageinstalls']
      verbs: ['*']
    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: default-developer-permissions
      namespace: #@ user
      annotations:
        kapp.k14s.io/change-rule: "upsert after upserting role"
        kapp.k14s.io/update-strategy:
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: kapp-permissions
    subjects:
      - kind: ServiceAccount
        name: default #! use value from "Install Default Supply Chain"
        namespace: #@ user
    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: default-permit-deliverable
      namespace: #@ user
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: deliverable
    subjects:
      - kind: ServiceAccount
        name: default #! use value from "Install Default Supply Chain"
        namespace: #@ user
    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: default-permit-workload
      namespace: #@ user
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: workload
    subjects:
      - kind: ServiceAccount
        name: default #! use value from "Install Default Supply Chain"
        namespace: #@ user
    ---
    apiVersion: scanning.apps.tanzu.vmware.com/v1alpha1
    kind: ScanPolicy
    metadata:
      name: scan-policy
      namespace: #@ "{}".format(user)
    spec:
      regoFile: |
        package policies

        default isCompliant = false

        # Accepted Values: "Critical", "High", "Medium", "Low", "Negligible", "UnknownSeverity"
        # "Critical","High","UnknownSeverity"
        violatingSeverities := []
        ignoreCVEs := []

        contains(array, elem) = true {
          array[_] = elem
        } else = false { true }

        isSafe(match) {
          fails := contains(violatingSeverities, match.Ratings.Rating[_].Severity)
          not fails
        }

        isSafe(match) {
          ignore := contains(ignoreCVEs, match.Id)
          ignore
        }

        isCompliant = isSafe(input.currentVulnerability)
    ---
    apiVersion: packaging.carvel.dev/v1alpha1
    kind: PackageInstall
    metadata:
      name: #@ "grype-{}".format(user)
      namespace: tap-install
    spec:
      packageRef:
        refName: grype.scanning.apps.tanzu.vmware.com
        versionSelection:
          constraints: 1.1.0
      serviceAccountName: tap-tap-install-sa
      values:
      - secretRef:
          name: #@ "grype-values-{}".format(user)
    ---
    apiVersion: v1
    kind: Secret
    metadata:
      name: #@ "grype-values-{}".format(user)
      namespace: tap-install
    stringData:
      values.yaml: #@ yaml.encode({ "namespace": user, "targetImagePullSecret": "registry-credentials" })
    ---
    apiVersion: tekton.dev/v1beta1
    kind: Pipeline
    metadata:
      name: developer-defined-tekton-pipeline
      namespace: #@ "{}".format(user)
      labels:
        apps.tanzu.vmware.com/pipeline: test
    spec:
      params:
        - name: source-url
        - name: source-revision
      tasks:
        - name: test
          params:
            - name: source-url
              value: $(params.source-url)
            - name: source-revision
              value: $(params.source-revision)
          taskSpec:
            params:
              - name: source-url
              - name: source-revision
            steps:
              - name: test
                image: gradle
                script: |-
                  cd `mktemp -d`

                  wget -qO- $(params.source-url) | tar xvz -m
                  ./mvnw test

    #@ registry_url = data.values.container_registry_location
    #@ registry_username = data.values.container_registry_username
    #@ registry_password = data.values.container_registry_password
    #@ docker_auth = base64.encode("{}:{}".format(registry_username, registry_password))
    #@ docker_creds = {"username": registry_username, "password": registry_password, "auth": docker_auth}

    ---
    apiVersion: v1
    data:
      .dockerconfigjson: #@ base64.encode(json.encode({"auths": {registry_url: docker_creds}}))
    kind: Secret
    metadata:
      name: registry-credentials
      namespace: #@ "{}".format(user)
    type: kubernetes.io/dockerconfigjson
    ---
    apiVersion: v1
    kind: Secret
    metadata:
      name: git-ssh
      namespace: #@ "{}".format(user)
      annotations:
        tekton.dev/git-0: #@ data.values.git_url
    type: kubernetes.io/ssh-auth
    data:
      identity: #@ data.values.git_ssh_private
      identity.pub: #@ data.values.git_ssh_public
      known_hosts: #@ data.values.git_ssh_known_hosts
      ssh-privatekey: #@ data.values.git_ssh_private
    #@ end