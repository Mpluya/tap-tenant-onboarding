#@ load("@ytt:data", "data")
#@ load("@ytt:yaml", "yaml")
---
apiVersion: kappctrl.k14s.io/v1alpha1
kind: App
metadata:
  name: app-onboarding
spec:
  serviceAccountName: tap-tap-install-sa
  fetch:
  - inline:
      pathsFrom:
      - secretRef:
          name: app-onboarding-files
  template:
  - ytt:
      ignoreUnknownComments: true
      valuesFrom:
      - secretRef:
          name: app-onboarding-secrets
      - secretRef:
          name: app-onboarding-values
  - kbld: {}
  deploy:
  - kapp: 
      rawOptions: ["--dangerous-override-ownership-of-existing-resources=true"]
---
apiVersion: v1
kind: Secret
metadata:
  name: app-onboarding-values
stringData:
  values.yaml: #@ yaml.encode({ "additional_users": data.values.additional_users })
---
apiVersion: v1
kind: Secret
metadata:
  name: app-onboarding-files
stringData:
  additional-users.yaml: |
    #@ load("@ytt:overlay", "overlay")
    #@ load("@ytt:data", "data")
    #@ load("@ytt:base64", "base64")
    #@ load("@ytt:json", "json")
    #@ load("@ytt:yaml", "yaml")

    #@ for user in data.values.additional_users:
    ---
    apiVersion: v1
    kind: Namespace
    metadata:
      name: #@ user
    ---
    apiVersion: v1
    kind: Secret
    metadata:
      name: tap-registry
      namespace: #@ user
      annotations:
        secretgen.carvel.dev/image-pull-secret: ""
    type: kubernetes.io/dockerconfigjson
    data:
      .dockerconfigjson: e30K

    ---
    apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: default #! use value from "Install Default Supply Chain"
      namespace: #@ user
    secrets:
      - name: registry-credentials
      - name: cosign
      - name: git-ssh
    imagePullSecrets:
      - name: tap-registry
      - name: registry-credentials
    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: Role
    metadata:
      name: tekton-task
      namespace: #@ user
    rules:
    - apiGroups: [tekton.dev]
      resources: [tasks]
      verbs: ['*']
    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: tekton-task-rolebinding
      namespace: #@ user
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: tekton-task
    subjects:
      - kind: ServiceAccount
        name: default #! use value from "Install Default Supply Chain"
        namespace: #@ user
    ---
    apiVersion: v1
    kind: Secret
    metadata:
      name: github #! default name of the secret for off the shelf Tekton Task to open a pull request
      namespace: #@ user
    type: Opaque
    data:
      token: #@ data.values.github_pr_token
    ---
    apiVersion: tekton.dev/v1beta1
    kind: Task
    metadata:
      name: github-open-pr-task
      namespace: #@ user
      labels:
        task: open-github-pr
      annotations:
        tekton.dev/categories: Git
        tekton.dev/pipelines.minVersion: "0.12.1"
        tekton.dev/tags: github
        tekton.dev/displayName: "open github pull request"
        tekton.dev/platforms: "linux/amd64,linux/s390x,linux/ppc64le"
    spec:
      description: >-
        This task will open a PR on Github based on several parameters.
        This could be useful in GitOps repositories for example.

      params:
      - name: GITHUB_HOST_URL
        description: |
          The GitHub host, adjust this if you run a GitHub enteprise.
        default: "api.github.com"
        type: string

      - name: API_PATH_PREFIX
        description: |
          The API path prefix, GitHub Enterprise has a prefix e.g. /api/v3
        default: ""
        type: string

      - name: REPO_FULL_NAME
        description: |
          The GitHub repository full name, e.g.: tektoncd/catalog
        type: string

      - name: GITHUB_TOKEN_SECRET_NAME
        description: |
          The name of the kubernetes secret that contains the GitHub token, default: github
        type: string
        default: github

      - name: GITHUB_TOKEN_SECRET_KEY
        description: |
          The key within the kubernetes secret that contains the GitHub token, default: token
        type: string
        default: token

      - name: AUTH_TYPE
        description: |
          The type of authentication to use. You could use the less secure "Basic" for example
        type: string
        default: Bearer

      - name: HEAD
        description: |
          The name of the branch where your changes are implemented.
        type: string

      - name: BASE
        description: |
          The name of the branch you want the changes pulled into.
        type: string

      - name: BODY
        description: |
          The body description of the pull request.
        type: string

      - name: TITLE
        description: |
          The title of the pull request.
        type: string

      results:
        - name: NUMBER
          description: Number of the created pull request.

        - name: URL
          description: URL of the created pull request.

      volumes:
      - name: githubtoken
        secret:
          secretName: $(params.GITHUB_TOKEN_SECRET_NAME)

      steps:
        - name: open-pr
          volumeMounts:
            - name: githubtoken
              readOnly: true
              mountPath: /etc/github-open-pr
          env:
            - name: PULLREQUEST_NUMBER_PATH
              value: $(results.NUMBER.path)
            - name: PULLREQUEST_URL_PATH
              value: $(results.URL.path)

          image: registry.access.redhat.com/ubi8/python-38:1-34.1599745032
          script: |
            #!/usr/libexec/platform-python

            """This script will open a PR on Github"""

            import json
            import os
            import sys
            import http.client

            github_token = open("/etc/github-open-pr/$(params.GITHUB_TOKEN_SECRET_KEY)", "r").read()

            open_pr_url = "$(params.API_PATH_PREFIX)" + "/repos/$(params.REPO_FULL_NAME)/pulls"

            data = {
                "head": "$(params.HEAD)",
                "base": "$(params.BASE)",
                "title": "$(params.TITLE)",
                "body": """$(params.BODY)"""
            }
            print("Sending this data to GitHub: ")
            print(data)

            authHeader = "$(params.AUTH_TYPE) " + github_token

            # This is for our fake github server
            if "$(params.GITHUB_HOST_URL)".startswith("http://"):
                conn = http.client.HTTPConnection("$(params.GITHUB_HOST_URL)"
                                                  .replace("http://", ""))
            else:
                conn = http.client.HTTPSConnection("$(params.GITHUB_HOST_URL)")

            conn.request(
                "POST",
                open_pr_url,
                body=json.dumps(data),
                headers={
                    "User-Agent": "TektonCD, the peaceful cat",
                    "Authorization": authHeader,
                    "Accept": "application/vnd.github.v3+json ",
                })
            resp = conn.getresponse()
            if not str(resp.status).startswith("2"):
                print("Error: %d" % (resp.status))
                print(resp.read())
                sys.exit(1)
            else:
                # https://docs.github.com/en/rest/reference/pulls#create-a-pull-request
                body = json.loads(resp.read().decode())

                open(os.environ.get('PULLREQUEST_NUMBER_PATH'), 'w').write(f'{body["number"]}')
                open(os.environ.get('PULLREQUEST_URL_PATH'), 'w').write(body["html_url"])

                print("GitHub pull request created for $(params.REPO_FULL_NAME): "
                      f'number={body["number"]} url={body["html_url"]}')
    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: default-permit-deliverable
      namespace: #@ user
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: deliverable
    subjects:
      - kind: ServiceAccount
        name: default #! use value from "Install Default Supply Chain"
        namespace: #@ user
    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: default-permit-workload
      namespace: #@ user
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: workload
    subjects:
      - kind: ServiceAccount
        name: default #! use value from "Install Default Supply Chain"
        namespace: #@ user
    ---
    apiVersion: scanning.apps.tanzu.vmware.com/v1alpha1
    kind: ScanPolicy
    metadata:
      name: scan-policy
      namespace: #@ "{}".format(user)
    spec:
      regoFile: |
        package policies

        default isCompliant = false

        # Accepted Values: "Critical", "High", "Medium", "Low", "Negligible", "UnknownSeverity"
        # "Critical","High","UnknownSeverity"
        violatingSeverities := []
        ignoreCVEs := []

        contains(array, elem) = true {
          array[_] = elem
        } else = false { true }

        isSafe(match) {
          fails := contains(violatingSeverities, match.Ratings.Rating[_].Severity)
          not fails
        }

        isSafe(match) {
          ignore := contains(ignoreCVEs, match.Id)
          ignore
        }

        isCompliant = isSafe(input.currentVulnerability)
    ---
    apiVersion: packaging.carvel.dev/v1alpha1
    kind: PackageInstall
    metadata:
      name: #@ "grype-{}".format(user)
      namespace: tap-install
    spec:
      packageRef:
        refName: grype.scanning.apps.tanzu.vmware.com
        versionSelection:
          constraints: 1.1.0
      serviceAccountName: tap-tap-install-sa
      values:
      - secretRef:
          name: #@ "grype-values-{}".format(user)
    ---
    apiVersion: v1
    kind: Secret
    metadata:
      name: #@ "grype-values-{}".format(user)
      namespace: tap-install
    stringData:
      values.yaml: #@ yaml.encode({ "namespace": user, "targetImagePullSecret": "registry-credentials" })
    ---
    apiVersion: v1
    kind: Secret
    metadata:
      name: cosign
      namespace: #@ user
      annotations:
        kpack.io/cosign.docker-media-types: "1"
    type: Opaque
    data:
      cosign.key: #@ data.values.cosign_private
      cosign.password: #@ data.values.cosign_password
      cosign.pub: #@ data.values.cosign_public
    ---
    apiVersion: tekton.dev/v1beta1
    kind: Pipeline
    metadata:
      name: developer-defined-tekton-pipeline
      namespace: #@ "{}".format(user)
      labels:
        apps.tanzu.vmware.com/pipeline: test
    spec:
      params:
        - name: source-url
        - name: source-revision
      tasks:
        - name: test
          params:
            - name: source-url
              value: $(params.source-url)
            - name: source-revision
              value: $(params.source-revision)
          taskSpec:
            params:
              - name: source-url
              - name: source-revision
            steps:
              - name: test
                image: gradle
                script: |-
                  cd `mktemp -d`

                  wget -qO- $(params.source-url) | tar xvz -m
                  ./mvnw test

    #@ registry_url = data.values.container_registry_location
    #@ registry_username = data.values.container_registry_username
    #@ registry_password = data.values.container_registry_password
    #@ docker_auth = base64.encode("{}:{}".format(registry_username, registry_password))
    #@ docker_creds = {"username": registry_username, "password": registry_password, "auth": docker_auth}

    ---
    apiVersion: v1
    data:
      .dockerconfigjson: #@ base64.encode(json.encode({"auths": {registry_url: docker_creds}}))
    kind: Secret
    metadata:
      name: registry-credentials
      namespace: #@ "{}".format(user)
    type: kubernetes.io/dockerconfigjson
    ---
    apiVersion: v1
    kind: Secret
    metadata:
      name: git-ssh
      namespace: #@ "{}".format(user)
      annotations:
        tekton.dev/git-0: #@ data.values.git_url
    type: kubernetes.io/ssh-auth
    data:
      identity: #@ data.values.git_ssh_private
      identity.pub: #@ data.values.git_ssh_public
      known_hosts: #@ data.values.git_ssh_known_hosts
      ssh-privatekey: #@ data.values.git_ssh_private
    #@ end